{
  "name": "Hilbert",
  "tagline": "A library that generates a proof of an input Î£ |- F in Hilbert's system.",
  "body": "Efficient implementation of Hilbert's system\r\n\r\nSimply the main goal is to create a library that can give the steps of the proof of a given Sigma |- F task. For this we can use different algorithms. There are four algorithms to choose from.\r\n\r\nThis project is made in Visual Studio 2012.\r\n\r\nLinux support is added.\r\nTested with gcc 4.6.3\r\n\r\nBinaries: https://www.dropbox.com/sh/rbx9hzyhmgo0gbp/XzXTENXlw7\r\n\r\nHow to compile (with static library):\r\n\r\n\tUse the makefile in Proof/src\r\n\t\r\n\tOR\r\n\r\n\tFirst cd to Proof/src then use this command to create the objects:\r\n\tg++ -std=c++0x -c Formula/Atomic/*.cpp Formula/Compound/*.cpp Formula/Containers/*.cpp Formula/Containers/Sets/*.cpp Input/*.cpp Algorithm/*.cpp\r\n\r\n\tThen to create the library:\r\n\tar rcs libproof.a *.o\r\n\r\n\t\r\n\tLinking is simple, for example:\r\n\tg++ -std=c++0x Main.cpp -L. -lproof -o ProofUI\r\n\tBut the library's headers should be availabe for the code, which means they should be in the same directory.\r\n\r\n\r\nSome examples of proofs made by the lib using the axioms:\r\n1. (a -> (b -> c)) -> ((a -> b) -> (a -> c))\r\n2. a -> (b -> a)\r\n3. ((a -> ~) -> ~) -> a\r\n\r\nThe task:\r\n|- ((P->~)->P)->P\r\n\r\nAfter applying deduction: \r\n{ (P->~)->P } |- P\r\n\r\n\r\nThe proof is:\r\n1. (P->~)->P    from Sigma\r\n\r\n2. (P->~)->(P->(P->~))    Axiom: a->(b->a) [a/P->~] [b/P] \r\n\r\n3. ((P->~)->(P->(P->~)))->(((P->~)->P)->((P->~)->(P->~)))    Axiom: (a->(b->c))->((a->b)->(a->c)) [a/P->~] [c/P->~] [b/P] \r\n\r\n4. ((P->~)->P)->((P->~)->(P->~))    : Cut ((P->~)->(P->(P->~)))->(((P->~)->P)->((P->~)->(P->~))) with (P->~)->(P->(P->~))\r\n\r\n5. (P->~)->(P->~)    : Cut ((P->~)->P)->((P->~)->(P->~)) with (P->~)->P\r\n\r\n6. ((P->~)->(P->~))->(((P->~)->P)->((P->~)->~))    Axiom: (a->(b->c))->((a->b)->(a->c)) [a/P->~] [b/P] [c/~] \r\n\r\n7. ((P->~)->P)->((P->~)->~)    : Cut ((P->~)->(P->~))->(((P->~)->P)->((P->~)->~)) with (P->~)->(P->~)\r\n\r\n8. (P->~)->~    : Cut ((P->~)->P)->((P->~)->~) with (P->~)->P\r\n\r\n9. ((P->~)->~)->P    Axiom: ((a->~)->~)->a [a/P] \r\n\r\n10. P    : Cut ((P->~)->~)->P with (P->~)->~\r\n\r\n\r\nThe task:\r\n|- ~->F\r\n\r\nAfter applying deduction: \r\n{ ~ } |- F\r\n\r\n\r\nThe proof is:\r\n1. ~    from Sigma\r\n\r\n2. ~->((F->~)->~)    Axiom: a->(b->a) [a/~] [b/F->~] \r\n\r\n3. (F->~)->~    : Cut ~->((F->~)->~) with ~\r\n\r\n4. ((F->~)->~)->F    Axiom: ((a->~)->~)->a [a/F] \r\n\r\n5. F    : Cut ((F->~)->~)->F with (F->~)->~\r\n\r\nThe task:\r\n|- ((P->(Q->R))->(P->Q))->((P->(Q->R))->(P->R))\r\n\r\nAfter applying deduction: \r\n{ (P->(Q->R))->(P->Q), P->(Q->R), P } |- R\r\n\r\n\r\nThe proof is:\r\n1. P    from Sigma\r\n\r\n2. P->(Q->R)    from Sigma\r\n\r\n3. (P->(Q->R))->(P->Q)    from Sigma\r\n\r\n4. P->Q    : Cut (P->(Q->R))->(P->Q) with P->(Q->R)\r\n\r\n5. Q    : Cut P->Q with P\r\n\r\n6. Q->R    : Cut P->(Q->R) with P\r\n\r\n7. R    : Cut Q->R with Q",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}